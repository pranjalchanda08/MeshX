#!/usr/bin/env python3

"""
    Copyright Â© 2024 - 2025 MeshX
"""

import yaml
import os
import argparse

parser = argparse.ArgumentParser()

parser.add_argument('prod', type=str, help='Name of the target product')
parser.add_argument('--root', type=str, default="meshx", help='Root directory path for MeshX')

# Header block for autogenerated code
file_insert =   "/****************************************************************************\n"\
                " * MESHX AUTOGEN CODE\n"\
                "****************************************************************************/\n"\
                "#ifndef __MESHX_AUTO_GEN__\n#define __MESHX_AUTO_GEN__\n"

# Custom exception class for CodeGen
class CodeGenException(Exception):
    pass

class CodeGen(CodeGenException):
    def __init__(self,
                 target_name,
                 meshx_root,
                 prod_profile="scripts/prod_profile.yml",
                 model_profile="scripts/model_profile.yml"
            ):
        """
        Initialize the CodeGen class with product and model profiles in YAML format.

        Args:
            target_name (str): Name of the target product.
            prod_profile (str): Path to the product profile YAML file.
            model_profile (str): Path to the model profile YAML file.
        """
        self.max_el = 1
        self.target = target_name
        self.meshx_root = meshx_root
        # Load product and model profiles from YAML files
        with open(prod_profile) as pj:
            self.prod_profile = yaml.safe_load(pj)
        with open(model_profile) as mj:
            self.prod_profile.update(yaml.safe_load(mj))
        self.product_list = []
        self.product = None
        self.pid = None
        self.cid = self.prod_profile['prod']['cid']
        self.c_list = []  # List of source files
        self.inc_list = []  # List of include directories
        self.deps = {}  # Dependency dictionary
        self.__find_prod_from_target()
        self.file_insert = file_insert
        self.genfile_h = self.meshx_root + "/default/inc/codegen.h"
        self.define_fmt = "\n#define {}{}{}"
        if os.name == 'nt':
            os.system(f'echo.>{self.genfile_h}')  # Create the header file
        elif os.name =='posix':
            os.system(f'touch {self.genfile_h}')  # Create the header file

    def __str__(self):
        """
            Return the autogenerated code as a string.
        """
        return self.file_insert

    def __get_fmt_define(self, name, value):
        """
        Get the define format for the autogenerated code.
        """
        leng = 40 - len(name)
        return self.define_fmt.format(name, (" " * leng), value)

    def __find_prod_from_target(self):
        """
        Find the product from the target name.
        """
        self.product_list = self.prod_profile['prod']['products']
        for product in self.product_list:
            if product['name'] == self.target:
                self.product = product
                self.pid = self.product['pid']
        if self.product is None:
            raise CodeGenException("Product Not Found")

    def __get_src_from_path(self, path):
        """
        Get all source files from the given path.
        """
        path_walk = self.meshx_root + "/" + path
        for (root,dirs,files) in os.walk(path_walk):
            for file in files:
                if file.endswith('.c'):  # Check if the file ends with .c
                    filepath = f"{root}/{file}"
                    if filepath not in self.c_list:
                        self.c_list.append(filepath)  # Add full path to list
                if file.endswith('.h') and f"{root}" not in self.inc_list:
                    self.inc_list.append(root)

    def __resolve_dep_create_yml_dict(self, dep_s, value:int = 0):
        """
        Resolve dependencies and create a dictionary from the YAML file.
        """
        for _idx, dep in enumerate(self.prod_profile['elements']):
            if dep["name"] == dep_s:
                self.deps[dep_s] = {'path' : dep['path']}
                if isinstance(dep['macro']['value'], bool):
                    self.prod_profile['elements'][_idx]['macro']['value'] = True
                else:
                    self.prod_profile['elements'][_idx]['macro']['value'] = value

                for sub_dep in dep['deps']:
                    self.__resolve_dep_create_yml_dict(sub_dep)

    def close(self):
        """
        Close the CodeGen class and write the autogenerated code to a header file.
        """
        self.get_all_macro()
        self.file_insert += "\n\n#endif /* __MESHX_AUTO_GEN__ */"
        with open(self.genfile_h, 'w') as genfile:
            genfile.write(str(gen) + '\n')

    def get_common_defs(self):
        """
        Get common definitions from the product profile.
        """
        self.max_el = 1
        if self.product is not None:
            for element in self.product['elements']:
                values = element.values()
                for value in values:
                    self.max_el += value
        self.file_insert += self.__get_fmt_define("CONFIG_CID_ID", hex(self.cid))
        self.file_insert += self.__get_fmt_define("CONFIG_PID_ID", hex(self.pid))
        self.file_insert += self.__get_fmt_define("CONFIG_PRODUCT_NAME", f'"{self.target[:16:]}"')
        self.file_insert += self.__get_fmt_define("CONFIG_MAX_ELEMENT_COUNT", self.max_el)
        return self.file_insert

    def resolve_component_deps(self, component, value=0):
        """
        Resolve component dependencies and their dependencies.
        """
        if self.product is not None:
            comp_ptr = self.prod_profile['components'][component]
            comp_ptr['macros'][0]['value'] = value
            self.__get_src_from_path(comp_ptr['path'])
            for macro in comp_ptr['macros']:
                macro['value'] = value

    def resolve_base_models_deps(self, base_model):
        """
        Resolve base model dependencies and their dependencies.
        """
        res_base_model = self.prod_profile['base_models'][base_model]
        self.__get_src_from_path(res_base_model['path'])
        for macro in res_base_model['macros']:
            macro['value'] = True

    def resolve_default_models(self):
        """
        Resolve default models and their dependencies.
        """
        for model in self.prod_profile['models']:
            mod = self.prod_profile['models'][model]
            if mod['default']:
                self.__get_src_from_path(mod['path'])
                self.resolve_model_deps(model, 1)

    def resolve_default_components(self):
        """
        Resolve default components and their dependencies.
        """
        for comp in self.prod_profile['components']:
            com = self.prod_profile['components'][comp]
            if com['default']:
                com['macros'][0]['value'] = True
                self.__get_src_from_path(com['path'])

    def resolve_model_deps(self, model, val):
        """
        Resolve model dependencies and their dependencies.
        """
        res_model = self.prod_profile['models'][model]
        self.__get_src_from_path(res_model['path'])
        for macro in res_model['macros']:
            if isinstance(macro['value'], bool):
                macro['value'] = True
            else:
                macro['value'] += val
        if res_model['base_model'] is not None:
            self.resolve_base_models_deps(res_model['base_model'])

    def resolve_el_deps(self, element, value=0):
        """
        Resolve element dependencies and their dependencies.
        """
        if self.product is not None:
            element_ptr = self.prod_profile['elements'][element]
            element_ptr['macros'][0]['value'] = value
            self.__get_src_from_path(element_ptr['path'])
            for model_reg in element_ptr['models']:
                for model_key, model_val in model_reg.items():
                    self.resolve_model_deps(model_key, (model_val * value))

    def resolve_prod_el(self):
        """
        Resolve product elements and their dependencies.
        """
        if self.product is not None:
            for element in self.product['elements']:
                self.resolve_el_deps(list(element.keys())[0], list(element.values())[0])
            try:
                for component in self.product['components']:
                    self.resolve_component_deps(list(component.keys())[0], list(component.values())[0])
            except KeyError:
                pass

    def get_all_macro(self):
        """
        Get all macros from the product profile.
        """
        if self.product is not None:
            for _key in ['elements', 'models', 'base_models', 'components']:
                for __key in self.prod_profile[_key]:
                    for macro in self.prod_profile[_key][__key]['macros']:
                        self.file_insert += self.__get_fmt_define(macro['def'], int(macro['value']))

    def create_cmake_list(self):
        """
        Create a CMake list of source files and include directories.
        """
        self.c_list     = [entry.replace(self.meshx_root + "/", "") for entry in self.c_list]
        self.inc_list   = [entry.replace(self.meshx_root + "/", "") for entry in self.inc_list]
        cmake_c_list_str = [f'    "{x}"' for x in self.c_list]
        cmake_h_list_str = [f'    "{x}"' for x in self.inc_list]
        cmake_src_list = f"set(DEP_SRC \n{'\n'.join(cmake_c_list_str)} \n)"
        cmake_inc_list = f"set(DEP_INC \n{'\n'.join(cmake_h_list_str)} \n)"
        return cmake_src_list, cmake_inc_list

if __name__ == '__main__':
    args = parser.parse_args()
    gen = CodeGen(args.prod, args.root)
    gen.get_common_defs()
    gen.resolve_default_components()
    gen.resolve_prod_el()
    gen.resolve_default_models()
    gen.close()
    string_to_insert = gen.create_cmake_list()[0] + '\n' + gen.create_cmake_list()[1] + '\n'
    temp_content = ""
    with open(f"{args.root}/CMakeLists.tmp", "r+") as file:
        temp_content = file.read()  # Read the existing content
    with open(f"{args.root}/CMakeLists.txt", "w") as file:
        file.seek(0)  # Move the file pointer to the beginning
        file.write(string_to_insert + temp_content)  # Write the new string followed by the old content

    print(f">> Autogen code created! \n{gen}")
