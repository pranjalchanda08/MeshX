import yaml
import os
import sys

# Header block for autogenerated code
file_insert =   "/****************************************************************************\n"\
                " * AUTOGEN CODE\n"\
                "****************************************************************************/\n"\
                "#ifndef __AUTO_GEN__\n#define __AUTO_GEN__\n"

# Custom exception class for CodeGen
class CodeGenException(Exception):
    pass

class CodeGen(CodeGenException):
    def __init__(self,
                 target_name,
                 prod_profile="scripts/prod_profile.yml",
                 model_profile="scripts/model_profile.yml",
                 idf_yml="main/idf_component.yml"):
        """
        Initialize the CodeGen class with product and model profiles in YAML format.

        Args:
            target_name (str): Name of the target product.
            prod_profile (str): Path to the product profile YAML file.
            model_profile (str): Path to the model profile YAML file.
            idf_yml (str): Path to the IDF component YAML file.
        """
        self.max_el = 1
        self.target = target_name

        # Load product and model profiles from YAML files
        with open(prod_profile) as pj:
            self.prod_profile = yaml.safe_load(pj)
        with open(model_profile) as mj:
            self.prod_profile.update(yaml.safe_load(mj))

        self.product_list = []
        self.product = None
        self.pid = None
        self.cid = self.prod_profile['prod']['cid']
        self.c_list = []  # List of source files
        self.inc_list = []  # List of include directories
        self.deps = {}  # Dependency dictionary
        self.yml = idf_yml
        self.__find_prod_from_target()
        self.file_insert = file_insert
        self.genfile_h = "main/common/codegen.h"
        self.define_fmt = "\n#define {} {}"
        os.system(f'touch {self.genfile_h}')  # Create the header file

    def __str__(self):
        return self.file_insert

    def __find_prod_from_target(self):
        self.product_list = self.prod_profile['prod']['products']
        for product in self.product_list:
            if product['name'] == self.target:
                self.product = product
                self.pid = self.product['pid']
        if self.product is None:
            raise CodeGenException("Product Not Found")

    def __get_src_from_path(self, path):
        if path not in self.inc_list:
            self.inc_list.append(path)
        entries = os.listdir(path)
        files = [f for f in entries if os.path.isfile(os.path.join(path, f))]
        for file in files:
            if file.endswith('.c'):  # Check if the file ends with .c
                filepath = os.path.join(path, file)
                if filepath not in self.c_list:
                    self.c_list.append(filepath)  # Add full path to list

    def __resolve_dep_create_yml_dict(self, dep_s, value:int = 0):
        for _idx, dep in enumerate(self.prod_profile['elements']):
            if dep["name"] == dep_s:
                self.deps[dep_s] = {'path' : dep['path']}
                if isinstance(dep['macro']['value'], bool):
                    self.prod_profile['elements'][_idx]['macro']['value'] = True
                else:
                    self.prod_profile['elements'][_idx]['macro']['value'] = value

                for sub_dep in dep['deps']:
                    self.__resolve_dep_create_yml_dict(sub_dep)

    def close(self):
        self.get_all_macro()
        self.file_insert += "\n\n#endif /* __AUTO_GEN__ */"
        with open(self.genfile_h, 'w') as genfile:
            genfile.write(str(gen) + '\n')

    def get_common_defs(self):
        self.max_el = 1
        if self.product is not None:
            for element in self.product['elements']:
                values = element.values()
                for value in values:
                    self.max_el += value
        self.file_insert += self.define_fmt.format("CONFIG_CID_ID", self.cid)
        self.file_insert += self.define_fmt.format("CONFIG_PID_ID", self.pid)
        self.file_insert += self.define_fmt.format("CONFIG_PRODUCT_NAME", f'"{self.target[:16:]}"')
        self.file_insert += self.define_fmt.format("CONFIG_MAX_ELEMENT_COUNT", self.max_el)
        return self.file_insert

    def resolve_component_deps(self, component, value=0):
        if self.product is not None:
            comp_ptr = self.prod_profile['components'][component]
            comp_ptr['macros'][0]['value'] = value
            self.__get_src_from_path(comp_ptr['path'])
            for macro in comp_ptr['macros']:
                macro['value'] = value

    def resolve_base_models_deps(self, base_model):
        res_base_model = self.prod_profile['base_models'][base_model]
        self.__get_src_from_path(res_base_model['path'])
        for macro in res_base_model['macros']:
            macro['value'] = True

    def resolve_default_models(self):
        for model in self.prod_profile['models']:
            mod = self.prod_profile['models'][model]
            if mod['default']:
                self.__get_src_from_path(mod['path'])
                self.resolve_model_deps(model, 1)

    def resolve_model_deps(self, model, val):
        res_model = self.prod_profile['models'][model]
        self.__get_src_from_path(res_model['path'])
        for macro in res_model['macros']:
            if isinstance(macro['value'], bool):
                macro['value'] = True
            else:
                macro['value'] += val
        if res_model['base_model'] is not None:
            self.resolve_base_models_deps(res_model['base_model'])

    def resolve_el_deps(self, element, value=0):
        if self.product is not None:
            element_ptr = self.prod_profile['elements'][element]
            element_ptr['macros'][0]['value'] = value
            self.__get_src_from_path(element_ptr['path'])
            for model_reg in element_ptr['models']:
                for model_key, model_val in model_reg.items():
                    self.resolve_model_deps(model_key, (model_val * value))

    def resolve_prod_el(self):
        if self.product is not None:
            for element in self.product['elements']:
                self.resolve_el_deps(list(element.keys())[0], list(element.values())[0])
            try:
                for component in self.product['components']:
                    self.resolve_component_deps(list(component.keys())[0], list(component.values())[0])
            except KeyError:
                pass

    def get_all_macro(self):
        if self.product is not None:
            for _key in ['elements', 'models', 'base_models', 'components']:
                for __key in self.prod_profile[_key]:
                    for macro in self.prod_profile[_key][__key]['macros']:
                        self.file_insert += self.define_fmt.format(macro['def'],
                                                            int(macro['value']))
    def create_cmake_list(self):
        cmake_c_list_str = [f'    "../{x}"' for x in self.c_list]
        cmake_h_list_str = [f'    "../{x}"' for x in self.inc_list]
        cmake_src_list = f"set(DEP_SRC \n{'\n'.join(cmake_c_list_str)} \n)"
        cmake_inc_list = f"set(DEP_INC \n{'\n'.join(cmake_h_list_str)} \n)"
        return cmake_src_list, cmake_inc_list

if __name__ == '__main__':
    gen = CodeGen(sys.argv[1])
    gen.get_common_defs()
    gen.resolve_prod_el()
    gen.resolve_default_models()
    gen.close()
    string_to_insert = gen.create_cmake_list()[0] + '\n' + gen.create_cmake_list()[1] + '\n'
    temp_content = ""
    with open("main/CMakeLists.tmp", "r+") as file:
        temp_content = file.read()  # Read the existing content
    with open("main/CMakeLists.txt", "w") as file:
        file.seek(0)  # Move the file pointer to the beginning
        file.write(string_to_insert + temp_content)  # Write the new string followed by the old content
    # print(json.dumps(gen.deps, indent=4))

    print(f">> Autogen code created! \n{gen}")
