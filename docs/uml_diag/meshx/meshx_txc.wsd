@startuml meshx_txc

title "Tx Control Send/Receive Flow"

participant "MeshX Init" as MI
participant "Control Task" as CT
participant "Element" as EL
participant "model client" as MC
participant "base client" as BC
participant "Tx Control" as TXC
participant "TX Control Thread" as TXCT
participant "Transport Layer" as TL

== Tx Control Init ==
MI -> TXC: TXC_init()
note over TXC
    1. Initialize TXC data structure
    2. Initialize sequence number
    3. Initialize TXC queue
    4. Initialize TXC signal
    5. Initialize TXC thread
end note
TXC -> TXCT: TXC_thread()

== TX Path ==
EL -> MC: Element Payload
MC -> MC: client msg create
MC -> BC: Send gen client msg
BC -> TXC: meshx_txcm_request_send()
TXC -> TXC: create TXC process pkt
note over TXC
    1. TXC header:
        a) Request Type
            1. Enqueue and Send
            2. Send Only
            3. Resend
            4. ACK/NACK (flush)
        b) Model TXC function pointer
        c) Dest Address
    2. App Payload
    3. Payload Len
end note

TXC -> TXCT : signal TXC Thread

alt Enqueue and Send
    TXCT -> TXCT: enqueue msg to queue back
    TXCT -> TXCT: peek queue front
    alt msg_state == MESHX_TXCM_MSG_STATE_NEW
        TXCT -> TXCT : TX dequeue
        TXCT -> BC: cb call for platform sending
        BC -> TL: send msg to transport layer
        TXCT -> TXCT : msg.state = MESHX_TXCM_MSG_STATE_WAITING_ACK
        TXCT -> TXCT : enqueue msg to the tx q front
    end
else Send Only
    TXCT -> TXCT: enqueue msg to queue back
    alt msg_state == MESHX_TXCM_MSG_STATE_NEW
        TXCT -> TXCT : TX dequeue
        TXCT -> BC: cb call for platform sending
        BC -> TL: send msg to transport layer
    end
else Resend
    TXCT -> TXCT: TX dequeue
    TXCT -> TXCT: msg.retry_cnt--
    alt ms.retry_cnt > 0
        TXCT -> BC: cb call for platform sending
        BC -> TL: send msg to transport layer
        TXCT -> TXCT : msg.state = MESHX_TXCM_MSG_STATE_WAITING_ACK
        TXCT -> TXCT : enqueue msg to the tx q front
    else
        TXCT -> CT : CT pub (MSG_CODE_TXCM : MSG_EVT_TXCM_MSG_TIMEOUT)
        CT -> BC : CT despatch (MSG_CODE_TXCM : MSG_EVT_TXCM_MSG_TIMEOUT)
    end
else ACK/NACK (flush)
    TXCT -> TXCT: peek front msg
    alt msg.dest == ack.src
        TXCT -> TXCT: dequeue msg
    else
        TXCT -> TXCT: Print warning and wait for next signal
    end
    TXCT -> TXCT: Process further msg in TX q
end

== RX Path ==
TL -> CT: FROM BLE event
CT -> BC: ACK/NACK
alt ACK
    BC -> TXCT: TXC_send(flush)
    BC -> MC: ACK process
    MC -> CT: notify element for state change
CT -> EL: Process element
@enduml
